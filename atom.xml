<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>格物致知</title>
  
  <subtitle>FALL BEHIND OR DROP</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.elmi.cn/"/>
  <updated>2019-12-03T09:45:08.627Z</updated>
  <id>https://blog.elmi.cn/</id>
  
  <author>
    <name>Arthur Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How to reactive with reactor</title>
    <link href="https://blog.elmi.cn/2019/12/03/how-to-reactive-with-reactor/"/>
    <id>https://blog.elmi.cn/2019/12/03/how-to-reactive-with-reactor/</id>
    <published>2019-12-03T09:41:14.000Z</published>
    <updated>2019-12-03T09:45:08.627Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="reactive stream" scheme="https://blog.elmi.cn/tags/reactive-stream/"/>
    
  </entry>
  
  <entry>
    <title>Java函数式编程</title>
    <link href="https://blog.elmi.cn/2019/10/08/how-to-java-functional-programme/"/>
    <id>https://blog.elmi.cn/2019/10/08/how-to-java-functional-programme/</id>
    <published>2019-10-08T12:01:56.000Z</published>
    <updated>2019-10-08T15:58:08.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote><p>与面向对象、过程式编程并列的编程范式</p></blockquote><ul><li>函数是一等公民</li><li>强调将计算过程分解成可复用的函数，典型例子：<code>map</code>和<code>reduce</code>组合的<code>MapReduce</code>算法</li><li>函数是一种数学运算，要求必须是纯粹的，</li></ul><p>函数式编程的起源是一门叫做范畴论（<strong>Category Theory</strong>）的数学分支</p><a id="more"></a><p>什么是范畴呢？</p><blockquote><p>In mathematics, a category is an algebraic structure that comprises “objects” that are linked by “arrows”.</p></blockquote><img src="/2019/10/08/how-to-java-functional-programme/category.png" class=""><p>箭头表示范畴成员之间的关系，正式名称为“态射”（<em>morphism</em>）范畴论认为，同一个范畴的所有成员，就是不同状态的“变形”（<em>transformation</em>）。通过“态射”，一个成员可以变形成另一个成员。</p><p>范畴的数学模型</p><ul><li>所有成员是一个集合</li><li>变形关系是函数<br>也就是说，范畴论是集合论上的抽象，简单的理解就是“集合+函数”<br>理论上通过函数，范畴中的成员可以算出其他所有成员。</li></ul><p>范畴与容器</p><ul><li>值（<code>value</code>）</li><li>值的形变关系（<code>function</code>）</li></ul><ol><li>范畴论与函数式编程的关系</li><li>范畴论使用函数表达范畴之间的关系。</li><li>伴随范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就成了“函数式编程”</li><li>本质上函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是能用来写程序</li></ol><p>函数的合成（<code>compose</code>）</p><blockquote><p>函数合同满足结合律</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数个数相同</span></span><br><span class="line"><span class="function"><span class="title">compose</span><span class="params">(f, compose(g, h)</span></span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="title">componse</span><span class="params">(compose(f, g)</span></span>, h)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="title">componse</span><span class="params">(f, g, h)</span></span></span><br></pre></td></tr></table></figure><p>函数的柯里化</p><blockquote><p>把一个多参数的函数，转化为单参数函数</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addX</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addX(<span class="number">2</span>)(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>函数常规方法</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> Func&#123;</span><br><span class="line">    Object exc(Object obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> IO&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">val</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IO(Object <span class="keyword">val</span>)&#123;</span><br><span class="line">        this.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IO <span class="keyword">of</span>(Object <span class="keyword">val</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object join()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">val</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IO apply(IO io)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">of</span>(((Func)<span class="keyword">val</span>).exc(io.<span class="keyword">val</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IO map(Func func)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">of</span>(func.exc(<span class="keyword">val</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IO flatMap(Func func)&#123;</span><br><span class="line">        <span class="keyword">return</span> (IO) map(func).join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">        Func add = x -&gt; <span class="keyword">of</span>(<span class="string">"hello"</span>.equals(x) ? <span class="string">"world"</span> : x);</span><br><span class="line">        Func print = x -&gt; &#123;System.out.println(x); <span class="keyword">return</span> <span class="keyword">of</span>(x)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">of</span>(x -&gt; <span class="string">"hello"</span>).apply(<span class="keyword">of</span>(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">of</span>(<span class="string">"hello"</span>).flatMap(print);</span><br><span class="line">        <span class="keyword">of</span>(<span class="string">"hello"</span>).flatMap(add).flatMap(print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Lambda"><a href="#Java-Lambda" class="headerlink" title="Java Lambda"></a>Java Lambda</h2><p>简述<code>Java Se 8</code>中新引入的Lambda语言特性以及这些特性背后的设计思想</p><ul><li><code>Lambda</code>表达式</li><li>方法引用 &amp; 构造器引用</li><li>拓展的目标类型 &amp; 类型推导</li><li>接口中的默认、静态方法</li></ul><h3 id="Backgroud"><a href="#Backgroud" class="headerlink" title="Backgroud"></a>Backgroud</h3><p>面向对象编程使用带有方法的对象封装行为，函数式编程使用函数封装行为。<br><em>Java</em>的对象比较重量级，实例化一个类型会涉及不同的类型，并需要初始化字段和方法。<br><em>Java</em>有时会封装单函数对象，例如<code>Runnable</code>、<code>ActionListener</code>等</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Runnable&#123;</span><br><span class="line">    void <span class="builtin-name">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处并不需要专门定义一个类来实现<code>Runnable</code>，一般会使用匿名类型内联</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnbal()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>并行领域是个值得研究的领域，因为<strong>摩尔定律</strong>在此得到了重生，尽管没有更快的CPU，但是有更多的CPU，串行API就只能使用有限的计算能力</p><p>随着函数式编程风格的流行，Java需要提供一种尽可能轻量级的封装方式（<strong>model code as data</strong>），匿名内部类并不是一个好的选择</p><ol><li>语法过于冗余</li><li>内部类的<code>this</code>和外部容易使人误解</li><li>类型载入和实例创建语义不够灵活</li><li>无法捕获非<code>final</code>局部变量</li><li>无法对控制流程进行抽象</li></ol><p>以上多数问题均在<code>Java Se 8</code>中得到了解决</p><ul><li>通过提供更简洁的语法和局部作用域规则，解决了问题1 &amp; 2</li><li>通过提供更加灵活便于优惠的表达式语义，绕开了问题3</li><li>通过允许编译器推断变量的“常量性”，减轻了问题4</li></ul><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote><p><code>@FunctionalInterface</code></p></blockquote><p>每一个函数对象对应一个接口类型，便于和Java类型系统紧密结合。</p><ul><li>接口是Java类型系统的一部分</li><li>接口天然就拥有运行时表示（<em>Runtime representation</em>）</li><li>接口可以通过Javadoc注释来表达一些非正式的协定</li></ul><p>编译器会通过<code>@FunctionalInterface</code>注解来判断且检查是否满足函数式接口的要求<br>Java并没有引入了一个全新的结构化函数类型，而是选择了“使用已知类型”，因为现有的类库大量使用了函数式接口，我们可以用<code>lambda</code>表达式直接实现现有类库。<br><code>Java Se 7</code>中已存在的函数式接口：</p><ul><li><code>java.lang.Runnable</code></li><li><code>java.util.comcurrent.Callable</code></li><li><code>java.security.PrivilegedAction</code></li><li><code>java.util.Comparator</code></li><li><code>java.io.FileFilter</code></li><li><code>java.beans.PropertyChangeListener</code></li></ul><p><code>Java Se 8</code> 新增加了一个包，<code>java.util.function</code>包含了常用的函数式接口：</p><ul><li><code>Predicate&lt;T&gt;</code>，接收<code>T</code>返回<code>boolean</code></li><li><code>Consumer&lt;T&gt;</code>，接收<code>T</code>，无返回</li><li><code>Function&lt;T,R&gt;</code>，接收<code>T</code>，返回<code>R</code></li><li><code>Supplier&lt;T&gt;, IntSupplier&lt;T&gt;</code>，提供<code>T</code>（工厂），无参</li><li><code>UnaryOperator&lt;T&gt;</code>，接收<code>T</code>，返回<code>T</code></li><li><code>BinaryOperator&lt;T&gt;, LongBinaryOperator&lt;T&gt;</code>，接受两个<code>T</code>，返回<code>T</code></li><li><code>BiFunction&lt;T,U,R&gt;</code>，接收<code>T, U</code>，返回<code>R</code></li></ul><h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><blockquote><p>匿名类型最大的问题就其冗余的语法，lambda表达式提供了轻量的语法，解决了“高度问题”。</p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(parameters)</span> -&gt;</span> expression / statement || <span class="function"><span class="params">(parameters)</span> -&gt;</span> &#123;statements&#125;</span><br></pre></td></tr></table></figure><h3 id="Target-typing"><a href="#Target-typing" class="headerlink" title="Target typing"></a>Target typing</h3><blockquote><p>函数式接口的名称并不是Lambda表达式的一部分，Lambda表达式的类型由上下文推导得出。</p></blockquote><p>相同的Lambda表达式在不同的上下文中拥有不同的类型</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; c = <span class="function"><span class="params">()</span> -&gt;</span> <span class="string">"hello world"</span>;</span><br><span class="line">PrivilegedAction&lt;String&gt; p = <span class="function"><span class="params">()</span> -&gt;</span> <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><p>编译器利用上下文<em>所期待的类型</em>推导Lambda表达式的类型，<em>所期待的类型</em>就是目标类型，Lambda表达式只能出现在目标类型为函数式接口的上下文中。</p><p>Lambda表达式对目标类型也是有要求的，编译器会检查Lambda表达式的类型和目标类型的方法签名是否一致，当且仅当以下所有条件均满足时，Lambda表达式才可以被赋值给目标类型<code>F</code></p><ul><li><code>F</code>是一个函数式接口</li><li>Lambda表达式的参数和<code>T</code>的方法参数在数量和类型上对应</li><li>Lambda表达式的返回值和<code>T</code>的方法返回值兼容</li><li>Lambda表达式所抛出的异常和<code>T</code>的方法<code>throws</code>类型兼容</li></ul><p>Lambda表达式的参数类型可以从目标类型中推导出, 当只有一个参数时括号可省略</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; c = (<span class="symbol">x</span>, <span class="symbol">y</span>) -&gt; <span class="symbol">x</span>.compareTo(<span class="symbol">y</span>);</span><br><span class="line">FileFilter f = <span class="symbol">x</span> -&gt; <span class="symbol">x</span>.getName().endsWith(<span class="string">"xml"</span>);</span><br></pre></td></tr></table></figure><p>泛型方法调用和<code>&lt;&gt;</code>构造器调用也通过目标类型进行类型推导</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>empty<span class="constructor">List()</span>;</span><br></pre></td></tr></table></figure><h3 id="目标类型的上下文"><a href="#目标类型的上下文" class="headerlink" title="目标类型的上下文"></a>目标类型的上下文</h3><p>带有目标类型的上下文如下：</p><ul><li>变量声明</li><li>赋值</li><li>返回语句</li><li>数组初始化</li><li>方法和构造器参数</li><li>Lambda表达式的函数体</li><li>三元运算符</li><li>转型表达式</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; c = <span class="function"><span class="params">(x, y)</span> -&gt;</span> x.compareTo(y);</span><br><span class="line">Runnable r = <span class="function"><span class="params">()</span> -&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>方法参数的类型推导会涉及：重载解析 &amp; 参数类型推导。<br>当Lambda表达式作为方法参数时，重载解析会影响到Lambda表达式的目标类型。当Lambda表达式显式指定参数类型，编译器可以直接使用返回类型，当Lambda表达式的参数类型推导得出，重载解析会忽略函数体而只依赖表达式参数数量。</p><p>如果解析方法声明时存在二义性，则需要使用转型或显式Lambda表达式来提供更多的类型信息。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; s = list.stream().<span class="built_in">map</span>(x -&gt; x.getName());</span><br></pre></td></tr></table></figure><ul><li>显式Lambda表达式参数类型</li><li>Lambda表达式转型为<code>Function&lt;T,R&gt;</code></li><li>为泛型参数提供一个实际类型，<code>.&lt;String&gt;map(x -&gt; x.getName()</code></li></ul><p>Lambda表达式可以通过外部的目标类型推导出内部的返回类型，可以方便的编写返回函数的函数</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Callable&lt;String&gt;&gt; <span class="function"><span class="title">s</span> = <span class="params">()</span> -&gt;</span> <span class="function"><span class="params">()</span> -&gt;</span> <span class="string">"hello world"</span>;</span><br><span class="line">Object <span class="function"><span class="title">o</span> = <span class="params">(Callable)</span> <span class="params">()</span> -&gt;</span> <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><p>目标类型不仅适用于Lambda表达式，泛型也收益。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>checked<span class="constructor">List(<span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">class</span>)</span><br></pre></td></tr></table></figure><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>内部类中使用变量容易出错，继承的成员可能会把外部类的成员掩盖，未限定的<code>this</code>引用会指向内部类<br>相对于内部类，<code>Lambda</code>表达式的语义就十分简单，它不会继承<code>super</code>，也不会引入新的作用域。Lambda表达式基于词法作用域，其内外具有相同语义（如<code>for</code>循环一致）</p><h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><p>在<code>Java Se 7</code>中，编译器对内部类中引用的外部变量（即捕获的变量）要求必须声明为<code>final</code>，在<code>Java Se 8</code>中放宽了限制，对于<code>Lambda</code>表达式和内部类，允许在捕获有效只读的变量（本质上仍然是<code>final</code>，只是不用显式声明）</p><p>对<code>this</code>的引用，以及通过<code>this</code>对未限定字段、方法的引用在本质上都是调用<code>final</code>局部变量，当引用<code>this</code>时相当于捕获了<code>this</code>实例，其他情况下，不会保留任何对<code>this</code>的引用。<br>内部类实例会一直保留一个对外部类实例的强引用，而没有捕获<code>this</code>的Lambda表达式则不会保留其引用，避免造成内存泄漏。</p><p>Lambda表达式不支持修改捕获变量的另一个原因是可以使用<strong>规约</strong>来实现同样的效果。<code>java.util.stream</code>包提供了多种规约操作（如<code>sum</code>、<code>min</code>、<code>max</code>等）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = <span class="built_in">list</span>.stream<span class="literal">()</span>.map<span class="constructor">ToInt(<span class="params">x</span> -&gt; <span class="params">x</span>.<span class="params">size</span>()</span>).sum<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun() 等价于</span></span><br><span class="line"><span class="built_in">int</span> sum = <span class="built_in">list</span>.stream<span class="literal">()</span>.map<span class="constructor">ToInt(<span class="params">x</span> -&gt; <span class="params">x</span>.<span class="params">size</span>()</span>).reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><blockquote><p>隐式<code>Lambda</code>表达式</p></blockquote><p><code>Lambda</code>表达式允许定义一个匿名方法以及以函数式接口的方式使用，希望能够在已有的方法上实现同样的特性。<br>方法引用与<code>Lambda</code>表达式具有相同的特性（目标类型 &amp; 函数式接口），可直接通过方法名称引用已有的方法</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;<span class="built_in">String</span>&gt; c = Comparator.comparing(<span class="built_in">String</span><span class="type">::toString</span>);</span><br></pre></td></tr></table></figure><p><code>String::toString</code>可被看成<em>Lambda表达式</em>的简写,方法引用不会将语法变得更紧凑，但拥有更明确的语义（可通过方法名直接调用）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt; c1 = System::<span class="keyword">exit</span> <span class="regexp">//</span> void <span class="keyword">exit</span>(int status)</span><br><span class="line">Consumer&lt;String[]&gt; c2 = Arrays::sort; <span class="regexp">//</span> void sort(Object[] o)</span><br><span class="line">Callable&lt;List&lt;String&gt;&gt; c = Collections::emptyList;</span><br></pre></td></tr></table></figure><p>方法引用种类</p><ul><li>静态方法引用<code>ClassName::method</code></li><li>实例上的实例方法<code>ref::method</code></li><li>超类上的实例方法<code>super::method</code></li><li>类型上的实例方法<code>ClassName::method</code></li><li>构造方法<code>ClassName:method</code></li><li>数组构造方法<code>TypeName::new</code></li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">String</span>&gt; p = <span class="built_in">list</span><span class="type">::contains</span>;</span><br><span class="line"></span><br><span class="line">Callable&lt;Path&gt; c = () -&gt; path;</span><br><span class="line">Privileged&lt;Path&gt; p = c<span class="type">::call</span>;</span><br><span class="line"></span><br><span class="line">Function&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; f = <span class="built_in">String</span><span class="type">::toUpperCase</span>;</span><br></pre></td></tr></table></figure><p>一般不需要指定方法引用的参数类型，编译器可以推导出结果，但如果需要可以在<code>::</code>之前显式提供参数类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;<span class="built_in">int</span>[]&gt; f = <span class="built_in">int</span>[]::new;</span><br><span class="line"><span class="built_in">int</span>[] a = f.apply(<span class="number">3</span>);<span class="comment">// int[3]</span></span><br></pre></td></tr></table></figure><h3 id="默认方法-amp-静态方法"><a href="#默认方法-amp-静态方法" class="headerlink" title="默认方法 &amp; 静态方法"></a>默认方法 &amp; 静态方法</h3><blockquote><p><code>Lambda</code>表达式和方法引用提升了Java语言的表达能力，为了把代码即数据(<code>code as data</code>)变的更加容易，需要将这些特性融入到已有的库中。</p></blockquote><p>默认方法（被称为虚拟拓展方法或守护方法）的目标式解决在已有的类库增加功能，使得接口在发布之后仍能被逐步演化。<br>默认方法利用面向对象的方式向接口增加新的行为，接口方法可以是抽象的或默认的。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。默认方法不是抽象方法，所以可以向函数式接口中增加默认方法。</p><p>如下展示如何向<code>Iterator</code>接口中增加默认方法<code>skip</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Iterator&lt;E&gt;&#123;</span><br><span class="line">    boolean hasNaxt();</span><br><span class="line">    E next();</span><br><span class="line">    void <span class="builtin-name">remove</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> default </span>void skip(int i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(; i &gt; 0 &amp;&amp; hasNext(); i--) &#123;</span><br><span class="line">            next();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上<code>Iterator</code>定义，所有实现<code>Iterator</code>的类型都会继承<code>skip</code>方法，子类可以通过覆盖<code>skip</code>来提供更好的实现（移动游标或提供原子性操作等）<br>当接口继承其他接口时，既可以为所继承的抽象方法提供一个默认实现，也可为继承而来的默认方法提供一个新实现或把继承来的默认方法抽象化。</p><p>除了默认方法，<code>Java Se 8</code>还允许在接口中定义静态方法，这使得我们可以从接口直接调用和它相关的辅助方法，而不是从其它的类中调用（之前此种类对应的接口的复数命名，如<code>Collections</code>）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> &lt;T, U <span class="keyword">extends</span> <span class="built_in">Comparable</span>&lt;? <span class="keyword">super</span> U&gt;&gt; Comparator&lt;T&gt; comparing(<span class="built_in">Function</span>&lt;T, U&gt; f)&#123;</span><br><span class="line">    <span class="keyword">return</span> (x, y) -&gt; f.apply(x).compareTo(f.apply(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承默认方法<br>和其他方法一样，默认方法也可以被继承，大多数情况下继承行为和期待的一致。不过，当类型或接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决此冲突。</p><ul><li>类的方法声明优先于接口默认方法</li><li>被其他类型所覆盖的方法会被忽略（适用于<code>super</code>共享一个<code>method</code>的情况）</li></ul><p>为了演示第二条规则，假设<code>Collection</code>和<code>List</code>接口均提供了<code>removeAll</code>的默认实现，然后<code>Queue</code>继承并覆盖了<code>Collection</code>中的默认方法，在下面的<code>implements</code>从句中，<code>List</code>中方法声明会优先于<code>Queue</code>中的方法声明。</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">LinkedList</span>&lt;E&gt; implements <span class="type">List</span>&lt;E&gt;, <span class="type">Queue</span>&lt;E&gt; <span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>当独立的默认方法相冲突或默认方法和抽象方法相冲突时会产生编译错误。此时需要显式覆盖父类方法。一般会定义一个默认方法来显式选择父类方法。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface X implements Y, Z &#123;</span><br><span class="line">   <span class="built_in"> default </span>void draw &#123;</span><br><span class="line">        Y.super.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计Lambda时的一个重要目标就时新增的语言特性和库特性能够无缝结合。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>, <span class="keyword">new</span> Comparator&lt;User&gt;<span class="literal">()</span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> compare(User x, User y)&#123;</span><br><span class="line">        return x.get<span class="constructor">Name()</span>.compare<span class="constructor">To(<span class="params">y</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了Lambda表达式，可以去掉冗余的匿名内部类</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>, (x, y) -&gt; x.get<span class="constructor">Name()</span>.compare<span class="constructor">To(<span class="params">y</span>.<span class="params">getName</span>()</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助Comparator里的comparing方法来实现</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>, <span class="module-access"><span class="module"><span class="identifier">Comparator</span>.</span></span>comparing((User x) -&gt; x.get<span class="constructor">Name()</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型推导 &amp; 静态导入的帮助下，可以进一步简化</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>, comparing(x -&gt; x.get<span class="constructor">Name()</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的Lambda表达式实际上是`getName`的代理，可以使用方法引用替代</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>, comparing(User::getName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Collections.sort`并不是一个好的方式，可以在`List`中添加`sort`默认方法来提供更好的实现</span></span><br><span class="line"><span class="built_in">list</span>.sort(comparing(User::getName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，如果在`Comparator`中增加一个默认方法`reversed`，便可以容易的实现降序操作</span></span><br><span class="line"><span class="built_in">list</span>.sort(comparing(User::getName).reversed<span class="literal">()</span>);</span><br></pre></td></tr></table></figure><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><blockquote><p>A sequence of elments supporting sequential and parallel aggregate operations.</p></blockquote><p>映射方法</p><ul><li><code>filter</code></li><li><code>map</code></li><li><code>limit</code></li><li><code>distinct</code>（依赖<code>equals</code>方法）</li></ul><p>归纳方法</p><ul><li><code>count</code></li><li><code>collect</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">list</span><span class="selector-class">.stream</span>()<span class="selector-class">.filter</span>(<span class="selector-tag">x</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">x</span><span class="selector-class">.getAge</span>() &gt; 3)<span class="selector-class">.map</span>(<span class="selector-tag">x</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">x</span><span class="selector-class">.getName</span>())<span class="selector-class">.collect</span>(<span class="selector-tag">Collectors</span><span class="selector-class">.toList</span>());</span><br></pre></td></tr></table></figure><p>串行流 &amp; 并行流</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行流</span></span><br><span class="line">List&lt;User&gt; users = <span class="built_in">list</span>.stream<span class="literal">()</span>.collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行流</span></span><br><span class="line">List&lt;User&gt; users = <span class="built_in">list</span>.stream<span class="literal">()</span>.parallel<span class="literal">()</span>.collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br></pre></td></tr></table></figure><p>使用并行只需要<code>parallel()</code>即可<br>并行内部将数据分成多段，每段一个线程并行处理，然后join一起输出</p><p><code>distinct</code>，对<code>stream</code>中包含的元素去重（依赖<code>equals</code>）</p><img src="/2019/10/08/how-to-java-functional-programme/distinct.jpg" class=""><p><code>filter</code>，对<code>stream</code>中包含的元素使用给定的过滤函数进行过滤</p><img src="/2019/10/08/how-to-java-functional-programme/filter.jpg" class=""><p><code>map</code>，对stream中包含的元素使用给定的转换函数进行转换操作，jdk有三个对于原始类型的变种方法，分别是：<code>mapToInt</code>，<code>mapToLong</code>，<code>mapToDouble</code>，可以避免自动装、拆箱的消耗。</p><img src="/2019/10/08/how-to-java-functional-programme/map.bmp" class=""><p><code>flatMap</code>，与<code>map</code>类似，不同的是每个元素转换得到的是<code>stream</code>对象，会把子<code>stream</code>中的元素聚合到外部父集合中</p><img src="/2019/10/08/how-to-java-functional-programme/flatMap.jpg" class=""><p><code>peek</code>，生成一个包含原<code>stream</code>的所有元素的新<code>stream</code>，同时会提供一个消费函数<code>Consumer</code>实例，新<code>stream</code>元素被消费的时都会调用给定的<code>Consumer</code>函数</p><img src="/2019/10/08/how-to-java-functional-programme/peek.jpg" class=""><p><code>limit</code>，对于一个<code>stream</code>进行截断操作，获取其前N个元素，如果元素个数不足N，返回所有元素</p><img src="/2019/10/08/how-to-java-functional-programme/limit.jpg" class=""><p><code>skip</code>，返回一个丢弃N个元素后的新<code>stream</code>，如果元素个数不足N，返回空<code>stream</code></p><img src="/2019/10/08/how-to-java-functional-programme/skip.jpg" class=""><p>stream的操作都是<code>lazy</code>的，内部会依赖转换函数生成新的函数（不执行），在<code>reduce</code>时遍历<code>stream</code>，每个元素都执行新的函数。</p><h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><blockquote><p>可以简单的理解为归纳结果方法</p></blockquote><p>reduce可以分为两种</p><ul><li>可变归纳，将元素归纳到可变容器中，如<code>Collection</code>或<code>StringBuilder</code></li><li>其他归纳，除去可变都时其他，一般都是通过前一次归纳的结果当作下一次的入参，如<code>reduce</code>、<code>count</code>、<code>allMatch</code></li></ul><h5 id="可变归纳"><a href="#可变归纳" class="headerlink" title="可变归纳"></a>可变归纳</h5><p>只有一个方法<code>collect</code></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// supplier是一个工厂函数，生成容器</span></span><br><span class="line"><span class="comment">// accumulator将元素添加到容器中</span></span><br><span class="line"><span class="comment">// combiner将多个结果合并到一个容器中（主要用于并发中）</span></span><br><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; s = Lists.newArrayList(<span class="string">"hel"</span>,<span class="string">"xx"</span>,<span class="built_in">null</span>,<span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; withoutNull = s.stream().filter(x -&gt; <span class="built_in">null</span> != x).collect(ArrayList<span class="type">::new</span>, <span class="built_in">List</span><span class="type">::add</span>, <span class="built_in">List</span><span class="type">::addAll</span>);</span><br></pre></td></tr></table></figure><p>以下提供<code>collect</code>另外一个重写版本（依赖<code>Collector</code>）</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">R</span>, A&gt; <span class="keyword">R</span> collect(Collector&lt;? super T, A, <span class="keyword">R</span>) collector);</span><br></pre></td></tr></table></figure><p><code>Java Se 8</code>提供了工具类<code>Collectors</code></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l = s.stream().<span class="keyword">filter</span>(<span class="keyword">x</span> -&gt; <span class="keyword">null</span> != <span class="keyword">x</span>).collect(Collectors.toList())<span class="comment">;</span></span><br></pre></td></tr></table></figure><h5 id="其他归纳"><a href="#其他归纳" class="headerlink" title="其他归纳"></a>其他归纳</h5><p>reduce方法非常通用，简单介绍其最常用的两种重写方式</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Option&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">int sum = list.stream<span class="function"><span class="params">()</span>.<span class="title">reduce</span><span class="params">((x, y) -&gt; x + y)</span>.<span class="title">get</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>有一个常用的变种</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">int sum = list.stream<span class="function"><span class="params">()</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>, (x, y) -&gt; x + y)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="title">sum</span> = <span class="title">list</span>.<span class="title">stream</span><span class="params">()</span>.<span class="title">count</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><p>查询相关</p><ul><li><code>allMatch</code>，是否所有元素都满足</li><li><code>anyMatch</code>，任意元素是否满足</li><li><code>findFirst</code>，返回首个元素</li><li><code>noneMatch</code>，是否所有元素均不满足</li><li><code>max</code> &amp; <code>min</code>，使用给定的<code>Operator</code>计算值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;与面向对象、过程式编程并列的编程范式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;函数是一等公民&lt;/li&gt;
&lt;li&gt;强调将计算过程分解成可复用的函数，典型例子：&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;reduce&lt;/code&gt;组合的&lt;code&gt;MapReduce&lt;/code&gt;算法&lt;/li&gt;
&lt;li&gt;函数是一种数学运算，要求必须是纯粹的，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数式编程的起源是一门叫做范畴论（&lt;strong&gt;Category Theory&lt;/strong&gt;）的数学分支&lt;/p&gt;
    
    </summary>
    
    
      <category term="functional" scheme="https://blog.elmi.cn/categories/functional/"/>
    
    
      <category term="lambda" scheme="https://blog.elmi.cn/tags/lambda/"/>
    
      <category term="functional" scheme="https://blog.elmi.cn/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>translation</title>
    <link href="https://blog.elmi.cn/2019/07/30/translation/"/>
    <id>https://blog.elmi.cn/2019/07/30/translation/</id>
    <published>2019-07-30T04:57:13.000Z</published>
    <updated>2019-07-30T04:57:13.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>How to reactor</title>
    <link href="https://blog.elmi.cn/2019/07/22/how-to-reactor/"/>
    <id>https://blog.elmi.cn/2019/07/22/how-to-reactor/</id>
    <published>2019-07-22T14:38:44.000Z</published>
    <updated>2019-10-08T12:51:07.415Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>What’s Reactive</p><p>Why’s Reactive</p><p>How to reactive</p></blockquote><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><blockquote><p>基于事件驱动/订阅模型<br>Servlet3.0之前，线程会Block到业务处理完并返回后结束Servlet（单线程）<br>Servlet3.0规范中一个新特性：异步处理支持；在接收到请求之后，Servlet线程可以将耗时的task委派给另一个线程来完成，在不生成响应的情况下返回至容器（Master/Worker模型）</p></blockquote><p>在传统的编程范式中，一般通过<code>Iterator</code>模式来遍历一个序列，这种遍历方式是由调用者来控制节奏的，采用<code>pull</code>方式。每次通过<code>next()</code>方法来获取序列中的下一个值。</p><p><strong>Reactive Stream</strong>采用<code>push</code>方式，当publisher有新的数据产生时，这些数据会被<code>push</code>到<em>subcriber</em>来进行处理；在Stream中可以添加各种不同的操作来处理数据，形成数据链。这种以声明式添加的处理链只有在订阅操作时才会真正执行。</p><p>到一个重要的概念是<code>backpressure</code>，在基本的消息推送模式中，当消息发布者产生数据的速度过快时，会使得消息订阅的处理速度无法跟上产生的速度，从而给订阅者造成很大的压力。当压力过大时，有可能造成订阅者本身的奔溃，所产生的及联效应甚至<br>可能造成整个系统的瘫痪。<code>backpressure</code>的作用在于提供一种从订阅到生产者的反馈渠道。订阅者可以通过<code>request()</code>方法来声明其一次所能处理的消息<code>request()</code>方法调用</p><p>//TODO 反应式流规范？？？<br>Reactor完全基于反应式流规范设计和实现的库，Reactor也是Spring5中反应式编程的基础。</p><a id="more"></a><h3 id="Mono-amp-Flux"><a href="#Mono-amp-Flux" class="headerlink" title="Mono &amp; Flux"></a>Mono &amp; Flux</h3><blockquote><p>Reactor中的两个基本概念</p><p>核心组件</p></blockquote><p>Flux表示0～N个元素的异步序列，该序列可以包含三种不同类型的消息通知</p><ul><li>正常包含元素的消息</li><li>序列结束的消息</li><li>序列出错的消息</li></ul><p>当消息通知产生时，订阅者对应的方法会被调用。</p><ul><li>onNext</li><li>onComplete</li><li>onError</li></ul><p>Mono表示0～1个元素的异步序列。该序列中同样包含与Flux相同的三种类型的消息通知。Flux和Mono之间可以进行转换？？？<br>对一个Flux序列进行count操作，得到的结果是一个Mono<Long>对象，把两个Mono序列合并在一起，得到一个Flux对象？？？</p><p>有多种方式可以创建Flux序列</p><ul><li>just()，可以指定序列中包含的全部元素，创建出来的Flux序列在发布这些元素之后会自动结束。</li><li>fromArray fromIterable fromStream</li><li>empty()，创建一个不包含任何元素，只发布结束消息的序列</li><li>error，创建一个只包含错误消息的序列</li><li>never，创建一个不包含任何消息通知的序列</li><li>range</li><li>interval(Duration)，创建一个包含了从0开始递增的Long对象的序列，其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间</li><li>intervalMillis，与interval的作用相同，只不过指定来时间单位毫秒</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).subcribe&#123;println(it)&#125;</span><br><span class="line">Flux.fromArray(arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)).subcribe&#123;println(it)&#125;</span><br><span class="line">Flux.empty().subcribe&#123;println(it)&#125;</span><br><span class="line">Flux.error(RuntimeException(<span class="string">"Error"</span>)).subcribe&#123;println(it)&#125;</span><br><span class="line">Flux.range(<span class="number">10</span>,<span class="number">10</span>).subcribe&#123;println(it)&#125;</span><br><span class="line">Flux.interval(Duration.of(<span class="number">10</span>,ChronoUnit.SECONDS)).subcribe&#123;println(it)&#125;</span><br><span class="line">Flux.intervalMillis(<span class="number">3000</span>).subcribe&#123;println(it)&#125;</span><br></pre></td></tr></table></figure><p>以上只适合简单的序列生成，当逻辑复杂时，则应该使用generate或者create</p><p>generate通过同步和逐一的方式来产生Flux，序列的产生是通过调用所提供的SynchronousSink对象的next、complete、error方法来完成的。<br>逐一生成的含义是在具体的生成逻辑中，next方法只能最多被调用一次。在某些情况下，序列的生成可能是有状态的，需要用到某些状态对象。此时可以使用generate方法的另一种形式<br>generate(Callable<S> stateSupplier, BiFunction&lt;S,SynchronousSink&lt;T, S&gt;&gt; generator)，其中stateSupplier用来提供初始的状态对象。在进行序列生成时，状态对象会作为generate使用的第一个参数传入，<br>可以在对应的逻辑中对该状态进修改以供下一次生成时使用。</p><p>在如下示例中，第一个序列的生成逻辑中通过next()方法产生一个简单的值，然后通过complete()方法来结束该序列。<br>如果不调用complete()方法，所产生的是一个无限序列。第二个序列的生成逻辑中的状态对象是一个ArrayList对象。实际产生的值是一个随机数。产生的随机数被添加到ArrayList中。<br>当产生了10个数时，通过complete()方法来结束序列。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Flux.generate&#123;sink -&gt;  </span><br><span class="line">    sink.next(<span class="string">"hello"</span>)</span><br><span class="line">    sink.complete() <span class="comment">//如果不complete则生成一个无限序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flux.generate(&#123; mutableListOf() &#125;)&#123;list, sink -&gt;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line">    list.add(x)</span><br><span class="line">    sink.next(x)</span><br><span class="line">    <span class="keyword">if</span>(list.size == <span class="number">5</span>)&#123;</span><br><span class="line">        sink.complete()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;.subcribe&#123;println(it)&#125;</span><br></pre></td></tr></table></figure><p>create()</p><p>（目前推荐Kotlin的std.lib??）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T.toFlux() | T.toMono()</span><br></pre></td></tr></table></figure><p>Reactor是JVM的NIO编程基础，具有高效的需求管理。直接与Java8的CompletableFuture、Stream、Duration。</p><h3 id="8个比较维度"><a href="#8个比较维度" class="headerlink" title="8个比较维度"></a>8个比较维度</h3><table><thead><tr><th>维度</th><th>参考</th></tr></thead><tbody><tr><td>Composable</td><td>CompletableFuture</td></tr><tr><td>Lazy</td><td>Stream</td></tr><tr><td>Reusable</td><td>Optional</td></tr><tr><td>Asynchronous</td><td>Obervable(RxJava v1)</td></tr><tr><td>Cacheable</td><td>Observable(RxJava v2)</td></tr><tr><td>Push or Pull</td><td>Flowable(RxJava v2)</td></tr><tr><td>Backpressure</td><td>Flux(Reactor Core</td></tr><tr><td>Operator fusion</td><td>–</td></tr></tbody></table><h3 id="WebFlux-amp-WebMvc"><a href="#WebFlux-amp-WebMvc" class="headerlink" title="WebFlux &amp; WebMvc"></a>WebFlux &amp; WebMvc</h3><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><ul><li>异步响应</li><li>流式响应</li><li>背压</li><li>websocket支持</li></ul><h3 id="How-to-test-with-springboot"><a href="#How-to-test-with-springboot" class="headerlink" title="How to test with springboot"></a>How to test with springboot</h3><blockquote><p>mock &amp; integretion ??</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;What’s Reactive&lt;/p&gt;
&lt;p&gt;Why’s Reactive&lt;/p&gt;
&lt;p&gt;How to reactive&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基于事件驱动/订阅模型&lt;br&gt;Servlet3.0之前，线程会Block到业务处理完并返回后结束Servlet（单线程）&lt;br&gt;Servlet3.0规范中一个新特性：异步处理支持；在接收到请求之后，Servlet线程可以将耗时的task委派给另一个线程来完成，在不生成响应的情况下返回至容器（Master/Worker模型）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在传统的编程范式中，一般通过&lt;code&gt;Iterator&lt;/code&gt;模式来遍历一个序列，这种遍历方式是由调用者来控制节奏的，采用&lt;code&gt;pull&lt;/code&gt;方式。每次通过&lt;code&gt;next()&lt;/code&gt;方法来获取序列中的下一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reactive Stream&lt;/strong&gt;采用&lt;code&gt;push&lt;/code&gt;方式，当publisher有新的数据产生时，这些数据会被&lt;code&gt;push&lt;/code&gt;到&lt;em&gt;subcriber&lt;/em&gt;来进行处理；在Stream中可以添加各种不同的操作来处理数据，形成数据链。这种以声明式添加的处理链只有在订阅操作时才会真正执行。&lt;/p&gt;
&lt;p&gt;到一个重要的概念是&lt;code&gt;backpressure&lt;/code&gt;，在基本的消息推送模式中，当消息发布者产生数据的速度过快时，会使得消息订阅的处理速度无法跟上产生的速度，从而给订阅者造成很大的压力。当压力过大时，有可能造成订阅者本身的奔溃，所产生的及联效应甚至&lt;br&gt;可能造成整个系统的瘫痪。&lt;code&gt;backpressure&lt;/code&gt;的作用在于提供一种从订阅到生产者的反馈渠道。订阅者可以通过&lt;code&gt;request()&lt;/code&gt;方法来声明其一次所能处理的消息&lt;code&gt;request()&lt;/code&gt;方法调用&lt;/p&gt;
&lt;p&gt;//TODO 反应式流规范？？？&lt;br&gt;Reactor完全基于反应式流规范设计和实现的库，Reactor也是Spring5中反应式编程的基础。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="functional" scheme="https://blog.elmi.cn/tags/functional/"/>
    
      <category term="reactive" scheme="https://blog.elmi.cn/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>design-patterns</title>
    <link href="https://blog.elmi.cn/2019/07/16/design-patterns/"/>
    <id>https://blog.elmi.cn/2019/07/16/design-patterns/</id>
    <published>2019-07-16T15:01:51.000Z</published>
    <updated>2019-07-16T15:01:51.798Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.elmi.cn/2019/07/14/hello-world/"/>
    <id>https://blog.elmi.cn/2019/07/14/hello-world/</id>
    <published>2019-07-14T08:57:40.000Z</published>
    <updated>2019-10-08T14:48:49.877Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate (hexo g) 生成静态文件</span><br><span class="line">$ hexo server (hexo s) 启动本地服务</span><br><span class="line">$ hexo deploy (hexo d) 提交到远程仓库</span><br><span class="line">$ hexo new page <span class="string">"xx"</span>(hexo n page) 创建页面 </span><br><span class="line">$ hexo new <span class="string">"xx"</span> (hexo n <span class="string">""</span>) 创建文章</span><br><span class="line">$ hexo d -g 生成静态并提交到远程仓库</span><br><span class="line">$ hexo s -g 生成静态文件并启动本地预览</span><br><span class="line">$ hexo clean 清除本地 public 文件</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="x" scheme="https://blog.elmi.cn/categories/x/"/>
    
    
      <category term="demo" scheme="https://blog.elmi.cn/tags/demo/"/>
    
      <category term="hello" scheme="https://blog.elmi.cn/tags/hello/"/>
    
  </entry>
  
  <entry>
    <title>post title with whitespace</title>
    <link href="https://blog.elmi.cn/2019/07/14/post-title-with-whitespace/"/>
    <id>https://blog.elmi.cn/2019/07/14/post-title-with-whitespace/</id>
    <published>2019-07-14T08:57:40.000Z</published>
    <updated>2019-07-14T08:57:40.922Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Words</title>
    <link href="https://blog.elmi.cn/2015/12/18/words/"/>
    <id>https://blog.elmi.cn/2015/12/18/words/</id>
    <published>2015-12-18T08:55:40.000Z</published>
    <updated>2019-07-14T11:54:11.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h1><blockquote><p>人是很奇怪的，每日想的并不一定是做的，思想与实践是独立又有关联的两个状态。想的并不是做的，做的也不一定是想的。总是抱怨这那，与其有时间抱怨其实是现实自己的无能，你想了但是未做，也许想做但是没有做或者没时间、没法做，但结果都是没做。同样都是没做，有何资格对人说三道四。用自己坐的去让人产生思想这是很滑稽，想的做了足矣。</p></blockquote><h2 id="思考的层面"><a href="#思考的层面" class="headerlink" title="思考的层面"></a>思考的层面</h2><blockquote><p>更高的视野</p></blockquote><h2 id="做事的心态"><a href="#做事的心态" class="headerlink" title="做事的心态"></a>做事的心态</h2><blockquote><p>学会规划，不规划就在别人的规划里</p></blockquote><h2 id="思考的方式"><a href="#思考的方式" class="headerlink" title="思考的方式"></a>思考的方式</h2><blockquote><p>知道如何做事</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闲言碎语&quot;&gt;&lt;a href=&quot;#闲言碎语&quot; class=&quot;headerlink&quot; title=&quot;闲言碎语&quot;&gt;&lt;/a&gt;闲言碎语&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;人是很奇怪的，每日想的并不一定是做的，思想与实践是独立又有关联的两个状态。想的并不是做的，做的也不
      
    
    </summary>
    
    
      <category term="NOTE" scheme="https://blog.elmi.cn/categories/NOTE/"/>
    
    
      <category term="life" scheme="https://blog.elmi.cn/tags/life/"/>
    
      <category term="essay" scheme="https://blog.elmi.cn/tags/essay/"/>
    
      <category term="无题" scheme="https://blog.elmi.cn/tags/%E6%97%A0%E9%A2%98/"/>
    
  </entry>
  
</feed>
